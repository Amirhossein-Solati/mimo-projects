import numpy as np
from itertools import product
from alamouti import alamouti



def alamouti_mld_bpsk(r, H):
    """
    Maximum Likelihood Detector for the Alamouti STBC with BPSK modulation.

    This function finds the most likely pair of transmitted BPSK symbols
    by checking all 4 possible combinations and selecting the one that
    minimizes the Euclidean distance to the received signal.

    Parameters
    ----------
    r : np.ndarray
        The received signal matrix, shape (2, 1). It contains signals
        received over two time slots.
    H : np.ndarray
        The channel matrix, shape (2, 1). It contains the channel gains
        from the two transmit antennas to the one receive antenna.

    Returns
    -------
    np.ndarray
        A column vector of shape (2, 1) containing the two detected BPSK symbols.
    """
    # 1. Define the BPSK constellation.
    sx = np.array([1, -1])

    # 2. Generate all possible combinations of two BPSK symbols.
    # `product(sx, repeat=2)` is equivalent to nested for loops.
    # It will generate tuples: (1, 1), (1, -1), (-1, 1), (-1, -1).
    # We convert this to a list of numpy arrays for easier processing.
    possible_symbol_pairs = [np.array(p) for p in product(sx, repeat=2)]

    # Variables to keep track of the best match found so far.
    min_cost = np.inf  # Initialize with infinity
    detected_symbols = None

    # 3. Iterate through each possible symbol pair to find the best one.
    # While this is still a loop, it's a single loop over 4 items, which is
    # very efficient. The complex calculations inside are now clearer.
    for symbol_pair in possible_symbol_pairs:
        # a. Create the hypothetical Alamouti code matrix for this pair.
        C = alamouti(symbol_pair)
        
        # b. Calculate the cost (squared Euclidean distance).
        # np.linalg.norm(..., 'fro') calculates the Frobenius norm, which for a
        # vector (or matrix) is the square root of the sum of the absolute
        # squares of its elements. Squaring it gives us the desired distance.
        # The operator '@' is for matrix multiplication in Python 3.5+.
        cost_matrix = r - (C @ H)
        cost = np.linalg.norm(cost_matrix, 'fro')**2
        
        # c. Compare with the minimum cost found so far.
        if cost < min_cost:
            min_cost = cost
            detected_symbols = symbol_pair

    # 4. Return the detected symbols as a column vector.
    # .reshape(2, 1) ensures the output shape matches the simulation's expectation.
    return detected_symbols.reshape(2, 1)

if __name__ == '__main__':
    # Create a sample received signal and channel
    # (These would be generated by the simulation's main loop)
    H_sample = np.array([[0.8+0.1j], [0.3-0.5j]]) # Channel gains h1, h2
    r_sample = np.array([[-0.4-0.8j], [1.2-0.3j]]) # Received signals r1, r2
    
    # Run the detector
    detected = alamouti_mld_bpsk(r_sample, H_sample)
    
    print("Sample Channel (H):\n", H_sample)
    print("Sample Received Signal (r):\n", r_sample)
    print("\nDetected Symbols:\n", detected)
    
    # Verify the output for a known case
    # Let's assume [-1, 1] was sent without noise
    sent_symbols = np.array([-1, 1])
    C_sent = alamouti(sent_symbols)
    r_noise_free = C_sent @ H_sample
    
    detected_noise_free = alamouti_mld_bpsk(r_noise_free, H_sample)
    print("\n--- Noise-Free Test ---")
    print("Sent Symbols:\n", sent_symbols.reshape(2,1))
    print("Detected Symbols (Noise-Free):\n", detected_noise_free)
    # The output should be [[-1.], [1.]]
    assert np.array_equal(sent_symbols.reshape(2,1), detected_noise_free)
    print("Noise-free test passed!")